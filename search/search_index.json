{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"EEEE EEEE* is a tiny framework for simple console input of values and generation of objects, which I wrote mainly for exercises of the university, because here often simple inputs with a scanner are needed, and I did not want to rewrite them again and again. Also, I didn't use any existing frameworks, ~~because apparently we are only allowed to use self-written code in the exams, and so I am allowed to use this mini-framework in the exams~~. EDIT: Looks like all frameworks are allowed. Well shit. NOTE: This framework is ab-so-lutely not suitable for production use. It should only serve for practice. Also, definitely not type-safe. Below, you can find some quick starts for each module. Installation Maven Add the JitPack repository to your pom.xml : <repositories> <repository> <id> jitpack.io </id> <url> https://jitpack.io </url> </repository> </repositories> Add the eeee -dependency: <dependency> <groupId> com.github.darmiel </groupId> <artifactId> eeee </artifactId> <version> -SNAPSHOT </version> </dependency> Gradle Add the JitPack repository to your build file: allprojects { repositories { ... maven { url 'https://jitpack.io' } } } Add the eeee -dependency: dependencies { implementation 'com.github.darmiel:eeee:Tag' } *) To be honest, I've already forgotten the meaning of the abbreviation. But it was certainly perfect!","title":"EEEE"},{"location":"#eeee","text":"EEEE* is a tiny framework for simple console input of values and generation of objects, which I wrote mainly for exercises of the university, because here often simple inputs with a scanner are needed, and I did not want to rewrite them again and again. Also, I didn't use any existing frameworks, ~~because apparently we are only allowed to use self-written code in the exams, and so I am allowed to use this mini-framework in the exams~~. EDIT: Looks like all frameworks are allowed. Well shit. NOTE: This framework is ab-so-lutely not suitable for production use. It should only serve for practice. Also, definitely not type-safe. Below, you can find some quick starts for each module.","title":"EEEE"},{"location":"#installation","text":"","title":"Installation"},{"location":"#maven","text":"Add the JitPack repository to your pom.xml : <repositories> <repository> <id> jitpack.io </id> <url> https://jitpack.io </url> </repository> </repositories> Add the eeee -dependency: <dependency> <groupId> com.github.darmiel </groupId> <artifactId> eeee </artifactId> <version> -SNAPSHOT </version> </dependency>","title":"Maven"},{"location":"#gradle","text":"Add the JitPack repository to your build file: allprojects { repositories { ... maven { url 'https://jitpack.io' } } } Add the eeee -dependency: dependencies { implementation 'com.github.darmiel:eeee:Tag' } *) To be honest, I've already forgotten the meaning of the abbreviation. But it was certainly perfect!","title":"Gradle"},{"location":"entrypoint/","text":"Entrypoint The framework makes it very easy to define multiple \"entry points\" (annotated with @Entrypoint ) without always having to write different main methods: public class Application { @Entrypoint ( \"World\" ) public void printWorld () { System . out . println ( \"World!\" ); } @Entrypoint ( \"Echo\" ) public void runEcho ( @Prompt ( \"What\" ) final String what ) { System . out . printf ( \"Echo! %s%n\" , what ); } } If you now start the program, invoking Starter.start in your main method, you will be asked which program you want to run: public static void main ( String [] args ) throws Exception { Starter . start ( Application . class , args ); } Console Output: 1. Application::World@printWorld () 2. Application::Echo@runEcho () [?] Select Method to run [1-2]: 1 --- Hello! --- Parse Arguments A method can have any number of arguments. If the type is a standard type (defined in the package: io.d2a.eeee.wrapper.wrappers ) the user is asked for an input and tries to parse the input: [string] What > test --- Echo! test --- You can customize the prompt by setting the @Prompt -annotation. This is optional, but without the annotation, you'd be prompted with arg0 , ..., arg{n} . Defaults Default values can be specified using the @Default annotation. @Entrypoint ( \"Echo\" ) public void echo ( @Default ( \"Nice\" ) @Prompt ( \"Echo\" ) final String input ) { System . out . println ( \"Echo! \" + input ); } Console-Output: [string] Echo [Nice] > {Enter} --- Echo! Nice --- Validation If you want to limit numbers to a certain range, or to limit a string to a certain length, you can use the @Range -annotation. The @Range -annotation accepts 1 to 3 arguments: @Range({1, 10}) -> 1 to 10 @Range({1, 10, 2}) -> 1 to 10 with steps of 2: 1, 3, 5, 7, 9 @Range(10) -> 0 to 10 @Entrypoint public void run ( @Range ({ 0 , 100 }) final int age ) { // ... } Console-Output: [int] [0-100] Age: -100 [int] [0-100] Age: 101 [int] [0-100] Age: 19 --- // ... --- Transform String inputs can be transformed during the parse process using the @Transform annotation. You can choose from the following actions: UPPER LOWER TRIM REVERSE @Entrypoint public void run ( @Prompt ( \"Name\" ) @Transform ({ Types . UPPER , Types . REVERSE }) final String name ){ System . out . println ( name ); } // input \"Michael\" will be transformed to \"LEAHCIM\" Custom Wrappers If you want to use your own types as parameters, these types must implement the Wrapper<T> interface: public class Rectangle implements Wrapper < Rectangle > { /** * @param scanner contains a Scanner which can be used to ask for input in the console * @param prompt contains the value of @Prompt() or the parameter name if empty * @param provider can be used to request annotations of a parameter, e. g. @Max * @return */ @Override public Rectangle wrap ( Scanner scanner , String prompt , AnnotationProvider provider ) { // See below for information about the Factory helper class return Factory . createClass ( scanner , Rectangle . class ); } } Now the rectangle can be used as a parameter in an Entry method: @Entrypoint public void run ( @Prompt ( \"Rect\" ) Rectangle rect ) { System . out . println ( rect ); } Console-Output: [int] [0-] Height:12 [int] [0-] Width:41 --- Rectangle{height=12,width=41} --- See example for a full example. See wrappers for some predefined wrappers","title":"Entrypoint"},{"location":"entrypoint/#entrypoint","text":"The framework makes it very easy to define multiple \"entry points\" (annotated with @Entrypoint ) without always having to write different main methods: public class Application { @Entrypoint ( \"World\" ) public void printWorld () { System . out . println ( \"World!\" ); } @Entrypoint ( \"Echo\" ) public void runEcho ( @Prompt ( \"What\" ) final String what ) { System . out . printf ( \"Echo! %s%n\" , what ); } } If you now start the program, invoking Starter.start in your main method, you will be asked which program you want to run: public static void main ( String [] args ) throws Exception { Starter . start ( Application . class , args ); } Console Output: 1. Application::World@printWorld () 2. Application::Echo@runEcho () [?] Select Method to run [1-2]: 1 --- Hello! ---","title":"Entrypoint"},{"location":"entrypoint/#parse-arguments","text":"A method can have any number of arguments. If the type is a standard type (defined in the package: io.d2a.eeee.wrapper.wrappers ) the user is asked for an input and tries to parse the input: [string] What > test --- Echo! test --- You can customize the prompt by setting the @Prompt -annotation. This is optional, but without the annotation, you'd be prompted with arg0 , ..., arg{n} .","title":"Parse Arguments"},{"location":"entrypoint/#defaults","text":"Default values can be specified using the @Default annotation. @Entrypoint ( \"Echo\" ) public void echo ( @Default ( \"Nice\" ) @Prompt ( \"Echo\" ) final String input ) { System . out . println ( \"Echo! \" + input ); } Console-Output: [string] Echo [Nice] > {Enter} --- Echo! Nice ---","title":"Defaults"},{"location":"entrypoint/#validation","text":"If you want to limit numbers to a certain range, or to limit a string to a certain length, you can use the @Range -annotation. The @Range -annotation accepts 1 to 3 arguments: @Range({1, 10}) -> 1 to 10 @Range({1, 10, 2}) -> 1 to 10 with steps of 2: 1, 3, 5, 7, 9 @Range(10) -> 0 to 10 @Entrypoint public void run ( @Range ({ 0 , 100 }) final int age ) { // ... } Console-Output: [int] [0-100] Age: -100 [int] [0-100] Age: 101 [int] [0-100] Age: 19 --- // ... ---","title":"Validation"},{"location":"entrypoint/#transform","text":"String inputs can be transformed during the parse process using the @Transform annotation. You can choose from the following actions: UPPER LOWER TRIM REVERSE @Entrypoint public void run ( @Prompt ( \"Name\" ) @Transform ({ Types . UPPER , Types . REVERSE }) final String name ){ System . out . println ( name ); } // input \"Michael\" will be transformed to \"LEAHCIM\"","title":"Transform"},{"location":"entrypoint/#custom-wrappers","text":"If you want to use your own types as parameters, these types must implement the Wrapper<T> interface: public class Rectangle implements Wrapper < Rectangle > { /** * @param scanner contains a Scanner which can be used to ask for input in the console * @param prompt contains the value of @Prompt() or the parameter name if empty * @param provider can be used to request annotations of a parameter, e. g. @Max * @return */ @Override public Rectangle wrap ( Scanner scanner , String prompt , AnnotationProvider provider ) { // See below for information about the Factory helper class return Factory . createClass ( scanner , Rectangle . class ); } } Now the rectangle can be used as a parameter in an Entry method: @Entrypoint public void run ( @Prompt ( \"Rect\" ) Rectangle rect ) { System . out . println ( rect ); } Console-Output: [int] [0-] Height:12 [int] [0-] Width:41 --- Rectangle{height=12,width=41} --- See example for a full example. See wrappers for some predefined wrappers","title":"Custom Wrappers"},{"location":"factory/","text":"Factory With the help of the Factory class you can now simplify the creation of a \"pojo\" class: import io.d2a.eeee.inject.Inject ; public class Rectangle { @Prompt ( \"Height\" ) private int height ; @Prompt ( \"Width\" ) private int width ; // or using the constructor for more control: @Prompt public Rectangle ( @Prompt ( \"Height\" ) final int height , @Prompt ( \"Width\" ) final int width ) { this . height = height ; this . width = width ; } } public class App { @Entrypoint ( \"Create Rectangle\" ) public void echo ( final Scanner scanner ) { Rectangle rect = Factory . createClass ( scanner , Rectangle . class ); System . out . println ( rect ); } }","title":"Factory"},{"location":"factory/#factory","text":"With the help of the Factory class you can now simplify the creation of a \"pojo\" class: import io.d2a.eeee.inject.Inject ; public class Rectangle { @Prompt ( \"Height\" ) private int height ; @Prompt ( \"Width\" ) private int width ; // or using the constructor for more control: @Prompt public Rectangle ( @Prompt ( \"Height\" ) final int height , @Prompt ( \"Width\" ) final int width ) { this . height = height ; this . width = width ; } } public class App { @Entrypoint ( \"Create Rectangle\" ) public void echo ( final Scanner scanner ) { Rectangle rect = Factory . createClass ( scanner , Rectangle . class ); System . out . println ( rect ); } }","title":"Factory"},{"location":"generate/","text":"Generator Sample objects can be created with the help of the RandomFactory . To do this, any constructor in the target class must be annotated with @Generate . NOTE: make sure all parameters can be generated. public class Person { private final String name ; private final int age ; @Generate public Person ( final String name , final int age ) { this . name = name ; this . age = age ; } // ... } // application public class App { @Entrypoint public void run () { final Person person = RandomFactory . generate ( Person . class ); System . out . println ( person ); // Person{name='AhgrEgVB', age=9} } } Customize generator The number ranges and string lengths can be adjusted with @Range . class Person { @Generate public Person ( final String name , @Range ( 100 ) final int age ) { this . name = name ; this . age = age ; } // or @Generate @Range ( 100 ) // applied for a and b public Person ( final int a , final int b ) { // ... } } You can implement your own generators by implementing the Generator interface in the class to be generated. public class A implements Generator < A > { @Override public A generate ( final Random random , final AnnotationProvider provider ) { return new A (); // generate something } } public class B { @Generate public B ( final A a ) { // ... } } Generators can be overridden for certain parameters using @Use : class Person { @Generate public Person ( @Use ( NameGenerator . class ) final String name , @Range ( 100 ) final int age ) { this . name = name ; this . age = age ; } } // RandomFactory.createRandom(Person.class) produces: // Person{name='Gary', age=54}","title":"Generator"},{"location":"generate/#generator","text":"Sample objects can be created with the help of the RandomFactory . To do this, any constructor in the target class must be annotated with @Generate . NOTE: make sure all parameters can be generated. public class Person { private final String name ; private final int age ; @Generate public Person ( final String name , final int age ) { this . name = name ; this . age = age ; } // ... } // application public class App { @Entrypoint public void run () { final Person person = RandomFactory . generate ( Person . class ); System . out . println ( person ); // Person{name='AhgrEgVB', age=9} } }","title":"Generator"},{"location":"generate/#customize-generator","text":"The number ranges and string lengths can be adjusted with @Range . class Person { @Generate public Person ( final String name , @Range ( 100 ) final int age ) { this . name = name ; this . age = age ; } // or @Generate @Range ( 100 ) // applied for a and b public Person ( final int a , final int b ) { // ... } } You can implement your own generators by implementing the Generator interface in the class to be generated. public class A implements Generator < A > { @Override public A generate ( final Random random , final AnnotationProvider provider ) { return new A (); // generate something } } public class B { @Generate public B ( final A a ) { // ... } } Generators can be overridden for certain parameters using @Use : class Person { @Generate public Person ( @Use ( NameGenerator . class ) final String name , @Range ( 100 ) final int age ) { this . name = name ; this . age = age ; } } // RandomFactory.createRandom(Person.class) produces: // Person{name='Gary', age=54}","title":"Customize generator"},{"location":"injector/","text":"Injection The framework includes a Mini-Injector functionality. Injected values can be used in entrypoint classes by default: import io.d2a.eeee.annotation.annotations.Entrypoint ; import io.d2a.eeee.inject.Inject ; public class App { @Inject private Scanner scanner ; // scanner which asks for user input // or: private final String [] args ; public App ( @Inject ( \"args\" ) final String [] args ) { this . args = args ; } @Entrypoint public void hello () { final String line = this . scanner . nextLine (); System . out . println ( line ); } } Default injectable values: Type Scanner , Name: None ( @Inject Scanner scanner ) Type: String[] , Name: args ( @Inject(\"args\") String[] args ) Custom Injection import io.d2a.eeee.inject.Inject ; public class App { @Inject ( \"name\" ) private String name ; private final int age ; public App ( @Inject int age ) { this . age = age ; } public static void main ( String [] args ) { final Injector injector = new Injector () . register ( String . class , \"Thorsten\" , \"name\" ) . register ( int . class , 22 ); final App app = injector . create ( App . class ); app . print (); } public void print () { System . out . printf ( \"%s is %d.%n\" , this . name , this . age ); } }","title":"Injection"},{"location":"injector/#injection","text":"The framework includes a Mini-Injector functionality. Injected values can be used in entrypoint classes by default: import io.d2a.eeee.annotation.annotations.Entrypoint ; import io.d2a.eeee.inject.Inject ; public class App { @Inject private Scanner scanner ; // scanner which asks for user input // or: private final String [] args ; public App ( @Inject ( \"args\" ) final String [] args ) { this . args = args ; } @Entrypoint public void hello () { final String line = this . scanner . nextLine (); System . out . println ( line ); } } Default injectable values: Type Scanner , Name: None ( @Inject Scanner scanner ) Type: String[] , Name: args ( @Inject(\"args\") String[] args )","title":"Injection"},{"location":"injector/#custom-injection","text":"import io.d2a.eeee.inject.Inject ; public class App { @Inject ( \"name\" ) private String name ; private final int age ; public App ( @Inject int age ) { this . age = age ; } public static void main ( String [] args ) { final Injector injector = new Injector () . register ( String . class , \"Thorsten\" , \"name\" ) . register ( int . class , 22 ); final App app = injector . create ( App . class ); app . print (); } public void print () { System . out . printf ( \"%s is %d.%n\" , this . name , this . age ); } }","title":"Custom Injection"}]}